import PushNotification from 'react-native-push-notification'

import {
  CLIENT_SET,
  CLIENT_UNSET,
  SET_INITIAL_LABELS,
  SET_ALERT,
  SET_ROOM_MESSAGE,
  RESET_UNREAD_MESSAGE,
  SET_ALERT_MESSAGE,
  SET_DEVICE_TOKEN,
  SET_SOCKET_CONNECT_STATUS,
  SET_SOCKET_RECONNECT,
  SEND_MESSAGE,
  SET_SEND_MESSAGE,
} from './types'

const initialState = {
  // id: null,
  token: null,
  initialLabels: null,
  alert: false,
  messages: {},
  sendingPool: {},
  pmid: 0,
  unreadMessages: {},
  wx: null,
  deviceToken: null,
  socketConnectStatus: false,
  socketReconnect: true,
}

export default (state = initialState, action) => {
  switch (action.type) {
    case CLIENT_SET:
      return {
        ...state,
        token: action.token,
      }
    case CLIENT_UNSET:
      return {
        ...state,
        token: null,
      }
    case SET_SOCKET_CONNECT_STATUS:
      return {
        ...state,
        socketConnectStatus: action.socketConnectStatus,
      }
    case SET_SOCKET_RECONNECT:
      return {
        ...state,
        socketReconnect: action.socketReconnect,
      }
    case SET_DEVICE_TOKEN:
      return {
        ...state,
        deviceToken: action.deviceToken,
      }
    case SET_INITIAL_LABELS:
      return {
        ...state,
        initialLabels: action.initialLabels,
      }
    case SET_ALERT:
      return {
        ...state,
        alert: action.alert,
      }
    case RESET_UNREAD_MESSAGE: {
      const unreadMessages = {
        ...state.unreadMessages,
        [action.id]: 0,
      }
      PushNotification.setApplicationIconBadgeNumber(
        Object.values(unreadMessages).reduce((a, b) => a + b),
      )
      return {
        ...state,
        unreadMessages,
      }
    }
    case SET_SEND_MESSAGE: {
      const message = { ...action.message, sending: true }
      const { local_id, room: roomId } = message
      const messages = { ...state.messages }
      let index = 0

      if (messages[roomId] !== undefined) {
        index = messages[roomId].length
        messages[roomId] = messages[roomId].concat(message)
      } else messages[roomId] = [message]
      const sendingPool = {
        ...state.sendingMessages,
        [local_id]: { roomId, index },
      }
      return {
        ...state,
        messages,
        sendingPool,
      }
    }
    case SET_ROOM_MESSAGE: {
      const messages = { ...state.messages }
      const unreadMessages = { ...state.unreadMessages }
      const sendingPool = { ...state.sendingPool }
      const data = action.message
      const pmid = data.id || state.pmid
      console.log('data.id: ', data.id)
      console.log('state.pmid: ', state.pmid)
      console.log('pmid: ', pmid)
      const roomId = data.room
      const showRoomId = action.id
      if (unreadMessages[roomId] !== undefined) {
        if (showRoomId !== roomId) {
          unreadMessages[roomId] += 1
        }
      } else unreadMessages[roomId] = 1

      if (data.local_id && sendingPool[data.local_id]) {
        const { roomId: id, index } = sendingPool[data.local_id]
        messages[id][index] = {
          ...messages[id][index],
          sending: false,
        }
        delete sendingPool[data.local_id]
      } else if (state.messages[roomId] !== undefined) {
        messages[roomId] = state.messages[roomId].concat(data)
      } else messages[roomId] = [data]
      // console.log('roomId: ', roomId)
      // PushNotification.localNotification({
      //   id: roomId,
      //   /* Android Only Properties
      //   id: '0', // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
      //   ticker: "My Notification Ticker", // (optional)
      //   autoCancel: true, // (optional) default: true
      //   largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
      //   smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
      //   bigText: "My big text that will be shown when notification is expanded", // (optional) default: "message" prop
      //   subText: "This is a subText", // (optional) default: none
      //   color: "red", // (optional) default: system default
      //   vibrate: true, // (optional) default: true
      //   vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
      //   tag: 'some_tag', // (optional) add tag to message
      //   group: "group", // (optional) add group to message
      //   ongoing: false, // (optional) set whether this is an "ongoing" notification

      //   /* iOS only properties*/
      //   // alertAction: // (optional) default: view
      //   // category: // (optional) default: null
      //   userInfo: { roomId }, // (optional) default: null (object containing additional notification data)
      //   /* iOS and Android properties */
      //   title: '新消息', // (optional, for iOS this is only used in apple watch, the title will be the app name on other iOS devices)
      //   message: `${data.sender.name}：${data.text}`, // (required)
      //   // playSound: true, // (optional) default: true
      //   soundName: 'default', // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. It can be set to a custom sound such as 'android.resource://com.xyz/raw/my_sound'. It will look for the 'my_sound' audio file in 'res/raw' directory and play it. default: 'default' (default sound is played)
      //   // number: global.unread, // (optional) Valid 32 bit integer specified as string. default: none (Cannot be zero)
      //   repeatType: 'day', // (Android only) Repeating interval. Could be one of `week`, `day`, `hour`, `minute, `time`. If specified as time, it should be accompanied by one more parameter 'repeatTime` which should the number of milliseconds between each interval
      //   // actions: '["Yes", "No"]',  // (Android only) See the doc for notification actions to know more
      // });
      const unreadArray = Object.values(unreadMessages)
      const unread = unreadArray.length > 0 ?
        unreadArray.reduce((a, b) => a + b) : 0
      PushNotification.setApplicationIconBadgeNumber(unread)
      return {
        ...state,
        messages,
        unreadMessages,
        pmid,
        sendingPool,
      }
    }
    case SET_ALERT_MESSAGE:
      return {
        ...state,
        messages: action.messages,
      }
    default:
      return state
  }
}
